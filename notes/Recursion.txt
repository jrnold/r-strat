One question is how to store the actions.

1. Nested list. 
2. Actions and terminal nodes object.  Action objects contain a slot for successors. Terminal nodes objects contain the label of the outcome to 
3. Similar to the above, but more in line with Chamber's (Programming with Data) method of storing trees.  There is one single argument for the tree.  Each slot is a vector of list with a specific characteristic for each node.  There is one slot that contains the successors of each node; each element is a character vector that points to other node labels in the object.

The algorithm is quite simple, but the implementation will depend on the data structure of actions. I need to clean up the pseudo-code.

U = utilities for each (player, outcome).

def CalcProbs(actions, U, private_info, p)
for each node:
    if action node:
        for x in successors:
            CalcProbs(x)
        p(successor 1) = pnorm( (U(1) - U(2)) / sqrt(pinfo(1) + pinfo(2) + agent(1) + agent(2)))
        p(successor 2) =  1 (p (successor 1))
        U(node) = p1 * U1 + p2 * U2
        pinfo(node) = p1^2
    if terminal node:
        U = U(player, outcome)
        pinfo = pinfo(player, outcome)
        

